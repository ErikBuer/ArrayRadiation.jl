var documenterSearchIndex = {"docs":
[{"location":"Examples/beem_steering/#Beam-Steering","page":"Beam Steering","title":"Beam Steering","text":"","category":"section"},{"location":"Examples/beem_steering/","page":"Beam Steering","title":"Beam Steering","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\n\n# Place elements symmetrically around zero\n\nelement_count = 64;\n\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\n\"\"\"\nInter-element phase shift for scanning in direction k [rad].\n\"\"\"\nα(θ) = -π * element_separation_λ * cos(π / 2 - θ);\n\n# Angles at which to scan the array.\nscan_angles = LinRange(-π / 2, π / 2, 81);\n\n# Use Hanning element weights. \nWp = Window.cosine_q(element_count, 2)\n\nplt1 = plot();\n\nanim = @animate for (index, scan_angle) in enumerate(scan_angles)\n\n\tphase_increment = α(scan_angle)\n\tW_ang = LinRange(0, (element_count - 1) * phase_increment, element_count)\n\n\t# Antenna element complex weight\n\tW = Wp.*exp.(im .* W_ang) # Example of pointing to an angle.\n\n\t# Map K-space gain calculation function.\n\tGΩ(k) = ArrayRadiation.Kspace.gain_2D(k, 1, r, W)\n\n\tGΩ_lin = broadcast(GΩ, angleRad)\n\tGΩ_dB = broadcast(ArrayRadiation.DspUtility.pow2db, abs.(GΩ_lin))\n\n\tplot(angleDeg, GΩ_dB,\n\t\txlabel = \"Angle [deg]\",\n\t\tylabel = \"GΩ [dB]\",\n\t\ttitle  = \"Array Gain\",\n\t\tylims  = (-80, 20),\n\t\treuse  = true,\n\t\tlegend = false\n\t\t)\nend\n\ngif(anim, \"array_scan.gif\", fps = 10)\n","category":"page"},{"location":"Examples/1D_array/#1D-Array","page":"1D Array","title":"1D Array","text":"","category":"section"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"Lets create an array and look at its radiation pattern.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"First we must place the antenna elements. Lets give them λ/2 spacing and spread them linearly.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\n\n# Place elements symmetrically around zero\nelement_count = 32;\n\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\nscatter(r, zeros(length(r)), \n    markershape=:circle, \n    # markercolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    title=\"Antenna Element Positions\", \n    legend=false, \n    #grid=false,\n    yticks= false,\n    ylims  = (-1, 1),\n)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"These elements now represent antennas. For the time being, these will be isotropic radiators. We can apply different weights to each element so lets look at how this will affect our array.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"Lets start by giving each element a uniform weight:","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"# Antenna element weigth\nW = ones(element_count)\n\nscatter(r, W, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=false, \n    grid=true,\n    ylims  = (0, 1.1),\n)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"With this defined, we can calculate the radiation pattern of the array.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\n\n# Map K-space gain calculation function.\nGΩ(k) = ArrayRadiation.Kspace.gain_2D(k, 1, r, W)\nGΩ_lin = broadcast(GΩ, angleRad)\n\nGΩ_dB = ArrayRadiation.DspUtility.pow2db.(abs.(GΩ_lin))\n\nplot(angleDeg, GΩ_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-30, 18),\n    reuse  = true,\n    legend = false\n)\n","category":"page"},{"location":"Examples/window_function/#Window-Function","page":"Window Function","title":"Window Function","text":"","category":"section"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\nelement_count = 32;\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"These elements now represent antennas. For the time being, these will be isotropic radiators. We can apply different weights to each element so lets look at how this will affect our array.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"Lets compare a linear weight to a commonly used Taylor weighting scheme.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"# Antenna element weigth\nW = ones(element_count)\nW2 = Window.taylor(32,4,-25)\n\nscatter(r, W, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=false, \n    grid=true,\n)\nscatter!(r, W2)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"As we can see, both weight functions have the same sum.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"sum(W)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"sum(W2)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"Now lets compare their radiation pattern.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\n\n# Map K-space gain calculation function.\nGΩ(k, _W) = Kspace.gain_2D(k, 1, r, _W)\nGΩ1_lin = map(k -> GΩ(k, W), angleRad)\nGΩ2_lin = map(k -> GΩ(k, W2), angleRad)\n\nGΩ1_dB = DspUtility.pow2db.(abs.(GΩ1_lin))\nGΩ2_dB = DspUtility.pow2db.(abs.(GΩ2_lin))\n\nplot(angleDeg, GΩ1_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-30, 18),\n    reuse  = true,\n    label  = \"Uniformly weighted\"\n)\n\nplot!(angleDeg, GΩ2_dB, \n    label  = \"Taylor weighted\"\n)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"It is apparent that the Taylor weighted antenna has greater peak to sidelobe distance, comming with the penalty of a wider main beam.","category":"page"},{"location":"Examples/window_function/#Window-Comparisons","page":"Window Function","title":"Window Comparisons","text":"","category":"section"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"Weighting distributions (windows) have been studied extensively over the years. The reader is encouraged to read up on the different windows and their properties.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"\nW3 = Window.cosine_q(element_count, 1)\nW4 = Window.cosine_q(element_count, 2)\n\n\nscatter(r, W2, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=true, \n    grid=true,\n    label  = \"Taylor weights\",\n)\nscatter!(r, W3, label  = \"Cosine weights\")\nscatter!(r, W4, label  = \"Hanning weights\")","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"GΩ3_lin = map(k -> GΩ(k, W3), angleRad)\nGΩ4_lin = map(k -> GΩ(k, W4), angleRad)\n\nGΩ3_dB = DspUtility.pow2db.(abs.(GΩ3_lin))\nGΩ4_dB = DspUtility.pow2db.(abs.(GΩ4_lin))\n\nplot(angleDeg, GΩ2_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-50, 18),\n    reuse  = true,\n    label  = \"Taylor weighted\"\n)\n\nplot!(angleDeg, GΩ3_dB, \n    label  = \"Cosine weighted\"\n)\n\nplot!(angleDeg, GΩ4_dB, \n    label  = \"Hanning weighted\"\n)","category":"page"},{"location":"#ArrayRadiation.jl-Documentation","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.jl Documentation","text":"","category":"section"},{"location":"","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.jl Documentation","text":"Modules = [ArrayRadiation, ArrayRadiation.DspUtility, ArrayRadiation.FrequencyDomain, ArrayRadiation.Kspace, ArrayRadiation.Window]","category":"page"},{"location":"#ArrayRadiation.DspUtility._mean-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility._mean","text":"_mean(x)::Real\n\nCalculate the mean of a vector. \n\njulia> using ArrayRadiation\n\njulia> a = [1,2,3,4];\n\njulia> ArrayRadiation.DspUtility._mean(a)\n2.5\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.db2mag-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.db2mag","text":"Convert between decibal scale (magnitude) and linear\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.db2pow-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.db2pow","text":"Convert between decibal scale (power) and linear\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.energy-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.energy","text":"Return the signal energy in Joule\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.linear_array-Tuple{Any, Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.linear_array","text":"Generate locations (1D) for an x*λ spaced array of N elements. N is even.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.mag2db-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.mag2db","text":"Convert between linear scale (magnitude) and decibel \n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.pow2db-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.pow2db","text":"Convert between linear scale (magnitude) and decibel \n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.power_dBW-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.power_dBW","text":"Return the average signal power in dBW\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.power_dBm-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.power_dBm","text":"Return the average signal power in dBm\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.FrequencyDomain.x_dB_bandwidth-Tuple{Any, Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.FrequencyDomain.x_dB_bandwidth","text":"Calculate the x dB bandwidth in number of bins.\n\njulia> FrequencyDomain.x_dB_bandwidth([1,2,3,4,5,4,3,2,1], 3)\n7\n\nArguments\n\nspectrum_dB The signal in frequency domain.\nx_dB \t\tThe level of reduction in the band, e.g. half powe BW (3 dB).\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Kspace.cos_taper","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.cos_taper","text":"Calculate 1D cosine taper for angle θ [rad]. Optionally provide α. α=1.4 accounts for mutual coupling between elements.\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\n\n\n\n\n","category":"function"},{"location":"#ArrayRadiation.Kspace.gain_2D","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.gain_2D","text":"Calculate GΩ(k), the angular domain gain at angle k [rad] for an array with specified element weights.\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\nArguments\n\nk\t\t\t\t\tAngle [rad].\nelement_gain\t\tThe antena gain in direction k [dB].\nelement_placement_λ The placement of each antenna element in wavelength units.\nelement_weighting\tThe complex weight of each element.\nα\t\t\t\t\tCosine taper/mutual coupling coefficient α>1.\n\n\n\n\n\n","category":"function"},{"location":"#ArrayRadiation.Kspace.maximum_element_separation-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.maximum_element_separation","text":"Calculate the maximum array element separation for maximum look angle. Result is fraction of wavelenth.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Window.cosine_q","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Window.cosine_q","text":"cosine_q(M::Integer, q, scale = true)::AbstractVector\n\nCreate a coseine^q weighting (window).\n\nArguments\n\nM       The length of the window.\nq       For q=0 yields a uniform weight,q=1 yelds a cosine weighting, and q=2 yields a Hanning weighting.\nscale   Max of window is 1, when not scaled. sum( cosine_q(M, q) ) = M when scaled.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> N = 64;\n\njulia> W = Window.cosine_q(N, 1);\n\njulia> round.( W[1:4], sigdigits=3 )\n4-element Vector{Float64}:\n 0.0385\n 0.116\n 0.192\n 0.269\n\njulia> round( sum(W), sigdigits=2)\n64.0\n\nReferences\n\nS. Yan, Broadband Array Processing, Springer, 2019\n\n\n\n\n\n","category":"function"},{"location":"#ArrayRadiation.Window.rangeOmit-Tuple{Any, Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Window.rangeOmit","text":"Returns 1:n but omits m.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Window.split_window-Tuple{AbstractVector}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Window.split_window","text":"split_window(W::AbstractVector)::AbstractVector\n\nSplit a window to create a difference beam\n\nArguments\n\nW       The window to split.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> N = 64;\n\njulia> W = Window.taylor(N, 4, -35);\n\njulia> W = Window.split_window(W);\n\njulia> round.( W[1:4], sigdigits=3 )\n4-element Vector{Float64}:\n 0.28\n 0.288\n 0.305\n 0.329\n\n\njulia> round.( W[N-3:N], sigdigits=3 )\n4-element Vector{Float64}:\n -0.329\n -0.305\n -0.288\n -0.28\n\nBelow is an example of a split Taylor window.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Window.taylor-Tuple{Integer, Integer, Real}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Window.taylor","text":"taylor(N::Integer, n_bar::Integer, sll_dB::Real)::AbstractVector\n\nCreate taylor weighting (window).\n\nArguments\n\nN       The window length.\nn_bar   The number of nearly constant-level sidelobes adjacent to the main lobe.\nsll_dB  Peak sidelobe_level in dB.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> W = Window.taylor(64, 4, -35);\n\njulia> round.( W[1:4], sigdigits=3 )\n4-element Vector{Float64}:\n 0.28\n 0.288\n 0.305\n 0.329\n\njulia> round( sum(W), sigdigits=5)\n64.0\n\nReferences\n\nCarrar, Goodman and Majewski, Spotlight Synthetic Aperture Radar: Signal Processing Algorithms, Artech House, 1995\n\n\n\n\n\n","category":"method"},{"location":"Examples/monopulse_pattern/#Monopulse-Pattern","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"","category":"section"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"For monopulse radar processing, we use a sum beam and a difference beam (on reception) in each axis, to estimate an angle to a target with the goal of tracking it.","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"We can create these two beams by playing with the element weights.","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\nelement_count = 32;\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\n# Antenna element weigth\nW = Window.taylor(32,4,-25)\nW2 = Window.split_window(copy(W))\n\nscatter(r, W, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=false, \n    grid=true,\n)\nscatter!(r, W2)","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"sum(W)","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"sum(W2)","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"Now lets compare their radiation pattern.","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\n\n# Map K-space gain calculation function.\nGΩ(k, _W) = Kspace.gain_2D(k, 1, r, _W)\nGΩ1_lin = map(k -> GΩ(k, W), angleRad)\nGΩ2_lin = map(k -> GΩ(k, W2), angleRad)\n\nGΩ1_dB = DspUtility.pow2db.(abs.(GΩ1_lin))\nGΩ2_dB = DspUtility.pow2db.(abs.(GΩ2_lin))\n\nplot(angleDeg, GΩ1_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-30, 18),\n    reuse  = true,\n    label  = \"Sum Beam\"\n)\n\nplot!(angleDeg, GΩ2_dB, \n    label  = \"Difference Beam\"\n)\n","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"As we can see, the difference beam is not great..","category":"page"}]
}
