var documenterSearchIndex = {"docs":
[{"location":"Examples/beem_steering/#Beam-Steering","page":"Beam Steering","title":"Beam Steering","text":"","category":"section"},{"location":"Examples/beem_steering/","page":"Beam Steering","title":"Beam Steering","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\n\n# Place elements symmetrically around zero\nelement_separation_λ = 1/2;\nelement_count = 64;\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\n\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\nelement_gain_approximation = Kspace.cos_taper.(angleRad)\n\n\"\"\"\nInter-element phase shift for scanning in direction θ [rad].\n\"\"\"\nα(θ, d_λ) = 2π*d_λ*sin(θ);\n\n# Angles at which to scan the array.\nscan_angles = LinRange(-π / 2, π / 2, 81);\n\n# Use Hanning element weights. \nWp = Window.cosine_q(element_count, 2)\n\nplt1 = plot();\n\nanim = @animate for (index, scan_angle) in enumerate(scan_angles)\n\n\tphase_increment = α(scan_angle, 1/2)\n\tW_ang = LinRange(0, (element_count - 1) * phase_increment, element_count)\n\n\t# Antenna element complex weight\n\tW = Wp.*exp.(im .* W_ang) # Example of pointing to an angle.\n\n\t# Map K-space gain calculation function.\n\tGΩ(k) = ArrayRadiation.Kspace.gain_1D(k, 1, r, W)\n\n\tGΩ_lin = broadcast(GΩ, k_xyz).*element_gain_approximation\n\tGΩ_dB = broadcast(ArrayRadiation.DspUtility.pow2db, abs.(GΩ_lin))\n\n\tplot(angleDeg, GΩ_dB,\n\t\txlabel = \"Angle [deg]\",\n\t\tylabel = \"GΩ [dB]\",\n\t\ttitle  = \"Array Gain\",\n\t\tylims  = (-80, 20),\n\t\treuse  = true,\n\t\tlegend = false\n\t\t)\nend\n\ngif(anim, \"array_scan.gif\", fps = 10)\n","category":"page"},{"location":"Examples/element_radiation_pattern/#Default-Element-Radiation-Pattern","page":"Default Element Radiation Pattern","title":"Default Element Radiation Pattern","text":"","category":"section"},{"location":"Examples/element_radiation_pattern/","page":"Default Element Radiation Pattern","title":"Default Element Radiation Pattern","text":"using GLMakie\nusing ArrayRadiation\n\nangleRad = LinRange(π / 2, -π / 2, 81);\n\nGe = Kspace.cos_taper.(angleRad)\nGe_dB = DspUtility.pow2db(Ge)\n\ny_lower_limit = -30 # dB\nGe_dB = clamp.(Ge_dB, y_lower_limit, Inf)\n\n# Create figure and polar axis\nf = Figure()\nax = PolarAxis(f[1, 1], \n    title = \"Element Radiation Pattern\",\n    thetalimits = (-pi/2, pi/2),\n    radius_at_origin = -30,\n    theta_0 = -pi/2,\n    direction = -1,\n)\nlines!(ax, angleRad, Ge_dB, color = :blue, linewidth = 2)\nf","category":"page"},{"location":"Examples/element_radiation_pattern/","page":"Default Element Radiation Pattern","title":"Default Element Radiation Pattern","text":"using GLMakie\nusing ArrayRadiation\n\n\n# Coordinate space to be modeled\nφs = range(0, 2π, length=361)   # angle within xy-plane relative to +x\nθs = range(0, π, length=181)    # angle relative to +z\nangles = [(φ,θ) for φ in φs, θ in θs]\n\n# Our antennas gain as a function of elevation and azimuth angle.\nGe(θ,φ) = Kspace.cos_taper(θ)\n\n# Get radius (the Element Gain) at each angle\nrs = [Ge(θ, φ) for (φ,θ) in angles]\n\n# Convert this data to a 2D mesh\nspherical_mesh = [(r,φ,θ) for (r,(φ,θ)) in zip(rs,angles)]\n\n# Convert spherical coordinates to rectangular coordinates\nxs = [r*sin(θ)*cos(φ) for (r,φ,θ) in spherical_mesh]\nys = [r*sin(θ)*sin(φ) for (r,φ,θ) in spherical_mesh]\nzs = [r*cos(θ)        for (r,φ,θ) in spherical_mesh]\n\n\n# Plot\nfig = Figure()\nax = Axis3(fig[1,1])\nplt = surface!(ax, xs, ys, zs,\n    color=rs,\n    colormap=:jet1\n)\nColorbar(fig[1,2], plt, label=\"Gain\")\nfig","category":"page"},{"location":"Examples/linear_array_polar_gain_pattern/#Linear-Array-Polar-Gain-Pattern","page":"Linear Array Polar Gain Pattern","title":"Linear Array Polar Gain Pattern","text":"","category":"section"},{"location":"Examples/linear_array_polar_gain_pattern/","page":"Linear Array Polar Gain Pattern","title":"Linear Array Polar Gain Pattern","text":"using GLMakie\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\n\n# Place elements symmetrically around zero\nelement_count = 32;\n\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nelement_gain_approximation = Kspace.cos_taper.(angleRad)\n\n# Uniform weights\nW = ones(element_count)\n\n\n# Calculate K-space vectors\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\n# Map K-space gain calculation function.\nGΩ(k) = Kspace.gain_1D(k, 1, r, W)\nGΩ_lin = broadcast(GΩ, k_xyz).*element_gain_approximation\n\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\n# Clamp dB values for readability\ny_lower_limit = -30\nGΩ_dB = clamp.(GΩ_dB, y_lower_limit, Inf)\n\nf = Figure()\nax = PolarAxis(f[1, 1], \n    title = \"Linear Array, Uniform Weights, $element_count Elements\",\n    thetalimits = (-pi/2, pi/2),\n    radius_at_origin = y_lower_limit,\n    theta_0 = -pi/2,\n    direction = -1,\n)\nlines!(ax, angleRad, GΩ_dB, color = :blue, linewidth = 2)\nf  # Display figure","category":"page"},{"location":"Examples/1D_array/#1D-Array","page":"1D Array","title":"1D Array","text":"","category":"section"},{"location":"Examples/1D_array/#1D-Radiation-Pattern","page":"1D Array","title":"1D Radiation Pattern","text":"","category":"section"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"Lets create an array and look at its radiation pattern.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"First we must place the antenna elements. Lets give them λ/2 spacing and spread them linearly.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"using Plots;\ngr();\nusing LaTeXStrings\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\n\n# Place elements symmetrically around zero\nelement_count = 32;\n\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\nscatter(r, zeros(length(r)), \n    markershape=:circle, \n    # markercolor=:blue, \n    markersize=4, \n    xlabel=\"Position [λ]\", \n    title=\"Element Positions\", \n    legend=false, \n    #grid=false,\n    yticks= false,\n    ylims  = (-1, 1),\n)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"These elements now represent the antenna placements. We use the cos_taper function to approzimate the element gain.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"angleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nelement_gain_approximation = Kspace.cos_taper.(angleRad)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"We can apply different weights to each element to create different beam directions.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"But in this example we give all elements a uniform weight:","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"# Antenna element weight\nW = ones(element_count)\n\nscatter(r, W, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=false, \n    grid=true,\n    ylims  = (0, 1.1),\n)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"With this defined, we can calculate the radiation pattern of the array.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"The propagation direciton is decided by the vector veck, as opposed to elevation and azimuth angles (θ ϕ).","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"veck = frac2πλ_0","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"# Calculate K-space vectors\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\n# Map K-space gain calculation function.\nGΩ(k) = Kspace.gain_1D(k, 1, r, W)\nGΩ_lin = broadcast(GΩ, k_xyz).*element_gain_approximation\n\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\nplot(angleDeg, GΩ_dB,\n    xlabel = \"Elevation [deg]\",\n    ylabel = L\"G_Ω\\; [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-30, 18),\n    reuse  = true,\n    legend = false\n)\n","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"We can now inspect the radiation pattern in one dimension. This is useful to get a sense of the performance.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"However one is often interrested in the complete radiaiton pattern in all dimensions.","category":"page"},{"location":"Examples/1D_array/#2D-Radiation-Pattern","page":"1D Array","title":"2D Radiation Pattern","text":"","category":"section"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"The default element radiation pattern Kspace.cos_taper only radiate forward, so a 2D plot shows all details of the current array.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"For simplicity, we calculate the radiation pattern from k_x k_y  -2pi 2pi.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"veck = k_xhatx + k_yhaty + k_zhatz","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"This yields invalid veck vectors with a magnitude greater than 2π (in our case) in the corners of the plot.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"But as you can see in the resulting radiation pattern, due to our element gain pattern, the array gain is nothing here anyways.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"resolution = 201\n\n# Create a 2D grid for x and y values\nx_vals = LinRange(-1, 1, resolution)\ny_vals = LinRange(-1, 1, resolution)\n\n# Initialize matrices to store the k-values\nk_z = zeros(resolution, resolution)\nGΩ_lin = zeros(resolution, resolution)\n\nfor m in 1:resolution\n    for n in 1:resolution\n        k_z[m, n] = sqrt(max(0, 1 - x_vals[n]^2 - y_vals[m]^2))\n    end\nend\n\nheatmap(x_vals, y_vals, k_z, \n    xlabel=L\"\\hat{k}_x\",\n    ylabel=L\"\\hat{k}_y\",\n    title=\"Values of \"*L\"\\hat{k}_z\",\n    color=:jet1\n)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"element_gain(elevation) = Kspace.cos_taper.(elevation, 1.4)\n\n# Calculate k_z values and gain values\nfor m in 1:resolution\n    for n in 1:resolution\n        k_x = x_vals[n]\n        k_y = y_vals[m]\n        k_z = sqrt(max(0, 1 - k_x^2 - k_y^2))\n        \n        # Create the k vector for each (k_x, k_y, k_z) triplet\n        k_xyz = 2π.*[k_x, k_y, k_z]\n\n        θ = Kspace.k2elevation(k_xyz)\n        \n        # Calculate the gain using the provided Kspace.gain_1D function\n        GΩ_lin[m, n] = GΩ(k_xyz)*element_gain(θ)\n        \n    end\nend\n\n# Convert the gain to dB\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\nGΩ_dB = clamp.(GΩ_dB, -40, Inf)\n\n# Plot the result as a heatmap\nheatmap(x_vals, y_vals, GΩ_dB, \n    xlabel=L\"\\hat{k}_x\", \n    ylabel=L\"\\hat{k}_y\", \n    title=L\"G_Ω(\\vec{k})\\; [dB]\", color=:jet1\n)","category":"page"},{"location":"Examples/2D_array/#2D-Array","page":"2D Array","title":"2D Array","text":"","category":"section"},{"location":"Examples/2D_array/#1D-Radiation-Pattern","page":"2D Array","title":"1D Radiation Pattern","text":"","category":"section"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"Lets create a 2D antenna array and look at its radiation pattern.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"First we must place the antenna elements. Lets give them λ/2 spacing and spread them equally.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"using Plots;\ngr();\nusing LaTeXStrings\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\n\n# Place elements symmetrically around zero\naxis_element_count = 32;\n\nr_xyz = ArrayRadiation.antenna_matrix(axis_element_count, axis_element_count, element_separation_λ)\n\n\n# Flatten and extract x and y coordinates\nx_positions = [r[1] for r in vec(r_xyz)]\ny_positions = [r[2] for r in vec(r_xyz)]\n\n# Plot\nscatter(x_positions, y_positions, \n    markershape=:circle, \n    markersize=4, \n    xlabel=\"X [λ]\", \n    ylabel=\"Y [λ]\", \n    title=\"Element Positions\", \n    legend=false, \n    grid=true\n)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"These elements now represent the antenna placements. We use the cos_taper function to approzimate the element gain.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"angleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nelement_gain_approximation = Kspace.cos_taper.(angleRad)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"We can apply different weights to each element to create different beam directions.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"But in this example we give all elements a uniform weight:","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"# Antenna element weight\nW = ones(axis_element_count, axis_element_count)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"With this defined, we can calculate the radiation pattern of the array.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"The propagation direciton is decided by the vector veck, as opposed to elevation and azimuth angles (θ ϕ).","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"veck = frac2πλ_0","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"# Calculate K-space vectors\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\n# Map K-space gain calculation function.\nGΩ(k) = Kspace.gain(k, 1, r_xyz, W)\nGΩ_lin = broadcast(GΩ, k_xyz).*element_gain_approximation\n\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\nplot(angleDeg, GΩ_dB,\n    xlabel = \"Elevation [deg]\",\n    ylabel = L\"G_Ω\\; [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-20, 30),\n    reuse  = true,\n    legend = false\n)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"We can now inspect the radiation pattern in one dimension. This is useful to get a sense of the performance.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"However one is often interrested in the complete radiaiton pattern in all dimensions.","category":"page"},{"location":"Examples/2D_array/#2D-Radiation-Pattern","page":"2D Array","title":"2D Radiation Pattern","text":"","category":"section"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"The default element radiation pattern Kspace.cos_taper only radiate forward, so a 2D plot shows all details of the current array.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"For simplicity, we calculate the radiation pattern from k_x k_y  -2pi 2pi.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"veck = k_xhatx + k_yhaty + k_zhatz","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"This yields invalid veck vectors with a magniture greater than 2π (in our case) in the corners of the plot.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"But as you can see in the resulting radiation pattern, due to our element gain pattern, the array gain is nothing here anyways.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"resolution = 201\n\n# Create a 2D grid for x and y values\nx_vals = LinRange(-1, 1, resolution)\ny_vals = LinRange(-1, 1, resolution)\n\n# Initialize matrices to store the k-values\nk_z = zeros(resolution, resolution)\nGΩ_lin = zeros(resolution, resolution)\n\nfor m in 1:resolution\n    for n in 1:resolution\n        k_z[m, n] = sqrt(max(0, 1 - x_vals[n]^2 - y_vals[m]^2))\n    end\nend\n\nheatmap(x_vals, y_vals, k_z, \n    xlabel=L\"\\hat{k}_x\",\n    ylabel=L\"\\hat{k}_y\",\n    title=\"Values of \"*L\"\\hat{k}_z\",\n    color=:jet1\n)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"element_gain(elevation) = Kspace.cos_taper.(elevation, 1.4)\n\n# Calculate k_z values and gain values\nfor m in 1:resolution\n    for n in 1:resolution\n        k_x = x_vals[n]\n        k_y = y_vals[m]\n        k_z = sqrt(max(0, 1 - k_x^2 - k_y^2))\n        \n        # Create the k vector for each (k_x, k_y, k_z) triplet\n        k_xyz = 2π.*[k_x, k_y, k_z]\n\n        θ = Kspace.k2elevation(k_xyz)\n        GΩ_lin[m, n] = GΩ(k_xyz)*element_gain(θ)\n        \n    end\nend\n\n# Convert the gain to dB\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\nGΩ_dB = clamp.(GΩ_dB, -40, Inf)\n\n# Plot the result as a heatmap\nheatmap(x_vals, y_vals, GΩ_dB, \n    xlabel=L\"\\hat{k}_x\", \n    ylabel=L\"\\hat{k}_y\", \n    title=L\"G_Ω(\\vec{k})\\; [dB]\",\n    color=:jet1\n)","category":"page"},{"location":"Examples/window_function/#Window-Function","page":"Window Function","title":"Window Function","text":"","category":"section"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\nelement_count = 32;\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"These elements now represent antennas. For the time being, these will be isotropic radiators. We can apply different weights to each element so lets look at how this will affect our array.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"Lets compare a linear weight to a commonly used Taylor weighting scheme.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"# Antenna element weight\nW = ones(element_count)\nW2 = Window.taylor(32,4,-25)\n\nscatter(r, W, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=false, \n    grid=true,\n)\nscatter!(r, W2)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"As we can see, both weight functions have the same sum.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"sum(W)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"sum(W2)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"Now lets compare their radiation pattern.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\nelement_gain_approximation = Kspace.cos_taper.(angleRad)\n\n\n# Map K-space gain calculation function.\nGΩ(k, _W) = Kspace.gain_1D(k, 1, r, _W)\nGΩ1_lin = map(k -> GΩ(k, W), k_xyz).*element_gain_approximation\nGΩ2_lin = map(k -> GΩ(k, W2), k_xyz).*element_gain_approximation\n\nGΩ1_dB = DspUtility.pow2db.(abs.(GΩ1_lin))\nGΩ2_dB = DspUtility.pow2db.(abs.(GΩ2_lin))\n\nplot(angleDeg, GΩ1_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-30, 18),\n    reuse  = true,\n    label  = \"Uniformly weighted\"\n)\n\nplot!(angleDeg, GΩ2_dB, \n    label  = \"Taylor weighted\"\n)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"It is apparent that the Taylor weighted antenna has greater peak to sidelobe distance, comming with the penalty of a wider main beam.","category":"page"},{"location":"Examples/window_function/#Window-Comparisons","page":"Window Function","title":"Window Comparisons","text":"","category":"section"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"Weighting distributions (windows) have been studied extensively over the years. The reader is encouraged to read up on the different windows and their properties.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"\nW3 = Window.cosine_q(element_count, 1)\nW4 = Window.cosine_q(element_count, 2)\n\n\nscatter(r, W2, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=true, \n    grid=true,\n    label  = \"Taylor weights\",\n)\nscatter!(r, W3, label  = \"Cosine weights\")\nscatter!(r, W4, label  = \"Hanning weights\")","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"GΩ3_lin = map(k -> GΩ(k, W3), k_xyz).*element_gain_approximation\nGΩ4_lin = map(k -> GΩ(k, W4), k_xyz).*element_gain_approximation\n\nGΩ3_dB = DspUtility.pow2db.(abs.(GΩ3_lin))\nGΩ4_dB = DspUtility.pow2db.(abs.(GΩ4_lin))\n\nplot(angleDeg, GΩ2_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-50, 18),\n    reuse  = true,\n    label  = \"Taylor weighted\"\n)\n\nplot!(angleDeg, GΩ3_dB, \n    label  = \"Cosine weighted\"\n)\n\nplot!(angleDeg, GΩ4_dB, \n    label  = \"Hanning weighted\"\n)","category":"page"},{"location":"#ArrayRadiation.jl-Documentation","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.jl Documentation","text":"","category":"section"},{"location":"","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.jl Documentation","text":"Modules = [ArrayRadiation, ArrayRadiation.DspUtility, ArrayRadiation.FrequencyDomain, ArrayRadiation.Kspace, ArrayRadiation.Window]","category":"page"},{"location":"#ArrayRadiation.DspUtility._mean-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility._mean","text":"_mean(x)::Real\n\nCalculate the mean of a vector. \n\njulia> using ArrayRadiation\n\njulia> a = [1,2,3,4];\n\njulia> ArrayRadiation.DspUtility._mean(a)\n2.5\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.antenna_matrix-Tuple{Any, Any, Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.antenna_matrix","text":"antenna_matrix(M, N, separation)\n\nGenerate locations (2D) for an evenly spaced MxN matrix of antenna elements,  ensuring symmetry around the origin.\n\nAll elements are placed in the XY-plane.\n\nArguments\n\nM          : Number of elements along the Y-axis.\nN          : Number of elements along the X-axis.\nseparation : Distance between adjacent elements.\n\nExample\n\n```jldoctest julia> using ArrayRadiation\n\njulia> DspUtility.antenna_matrix(1, 2, 0.5) 1×2 Matrix{Tuple{Float64, Float64, Float64}}:  (-0.25, 0.0, 0.0)  (0.25, 0.0, 0.0)\n\njulia> DspUtility.antenna_matrix(1, 3, 1/2) 1×3 Matrix{Tuple{Float64, Float64, Float64}}:  (-0.5, 0.0, 0.0)  (0.0, 0.0, 0.0)  (0.5, 0.0, 0.0)\n\njulia> DspUtility.antenna_matrix(2, 1, 1/2) 2×1 Matrix{Tuple{Float64, Float64, Float64}}:  (0.0, -0.25, 0.0)  (0.0, 0.25, 0.0) ````\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.db2mag-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.db2mag","text":"Convert between decibal scale (magnitude) and linear\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.db2pow-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.db2pow","text":"Convert between decibal scale (power) and linear\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.discard_low_values-Tuple{Real, Real}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.discard_low_values","text":"discard_low_values(scalar_value::Real, lower_limit::Real)\n\nThis function takes a scalar value and compares it against a specified lower limit. If the scalar value is below the lower_limit, the function returns nothing. Otherwise, it returns the scalar value unchanged.\n\nArguments\n\nscalar_value::Real: The scalar value to compare.\nlower_limit::Real: The threshold value below which the scalar is discarded.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> ArrayRadiation.DspUtility.discard_low_values(50, 40)\n50\n\njulia> ArrayRadiation.DspUtility.discard_low_values(30, 40)\n\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.energy-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.energy","text":"Return the signal energy in Joule\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.linear_array-Tuple{Any, Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.linear_array","text":"Generate locations (1D) for a evenly spaced array of N elements. N is even.\n\nArguments\n\nN          \tNumber of elements (assumed to be even).\nseparation \tDistance between adjacent elements.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.mag2db-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.mag2db","text":"Convert between linear scale (magnitude) and decibel \n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.pow2db-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.pow2db","text":"Convert between linear scale (magnitude) and decibel \n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.power_dBW-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.power_dBW","text":"Return the average signal power in dBW\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.DspUtility.power_dBm-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.DspUtility.power_dBm","text":"Return the average signal power in dBm\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.FrequencyDomain.x_dB_bandwidth-Tuple{Any, Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.FrequencyDomain.x_dB_bandwidth","text":"Calculate the x dB bandwidth in number of bins.\n\njulia> FrequencyDomain.x_dB_bandwidth([1,2,3,4,5,4,3,2,1], 3)\n7\n\nArguments\n\nspectrum_dB The signal in frequency domain.\nx_dB \t\tThe level of reduction in the band, e.g. half powe BW (3 dB).\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Kspace.azimuth2k_hat-Tuple{Real}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.azimuth2k_hat","text":"azimuth2k_hat(ϕ::Real)::Vector{Real}\n\nConvert an azimuth angle ϕ (in radians) to a unit-length k-space vector in the XY-plane.\nThe resulting vector has the form [cos(ϕ), sin(ϕ), 0].\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Kspace.cos_taper","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.cos_taper","text":"Calculate cosine taper for elevation angle θ [rad]. Optionally provide α. α=1.4 accounts for mutual coupling between elements.\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\n\n\n\n\n","category":"function"},{"location":"#ArrayRadiation.Kspace.cos_taper_k_hat","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.cos_taper_k_hat","text":"Calculate cosine taper for normalized k-space vector [kx, ky, kz]/|k|. Where |k| = 2π/λ0 Optionally provide α. α=1.4 accounts for mutual coupling between elements.\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\n\n\n\n\n","category":"function"},{"location":"#ArrayRadiation.Kspace.elevation2k_hat-Tuple{Real}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.elevation2k_hat","text":"elevation2k_hat(θ::Real)::Vector{Real}\n\nConvert an elevation angle θ (in radians) to a unit-length k-space vector in the XZ-plane.\nThe resulting vector has the form [sin(θ), 0, cos(θ)].\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Kspace.gain-Tuple{AbstractVector{<:Real}, Real, AbstractArray, AbstractArray}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.gain","text":"gain(k_xyz::AbstractVector{<:Real}, Ge::Real, r_xyz::AbstractArray, element_weights::AbstractArray)\n\nCalculate GΩ(k), the angular domain gain in direction k for an array with specified element weights.\n\nArguments\n\nk_xyz\t\t\t    k-space vector.\nGe\t\t\t\t\tThe antena gain in direction k_xyz [dB].\nr_xyz \t\t\t\tThe placement of each antenna element. in \nelement_weights\t    The complex weight of each element. Must have the same size/shape as r_xyz.\n\nReferences\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Kspace.gain_1D-Tuple{AbstractVector{<:Real}, Real, AbstractVector, AbstractVector}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.gain_1D","text":"gain_1D(k_xyz::AbstractVector{<:Real}, Ge::Real, r_x::AbstractVector, element_weights::AbstractVector)\n\nCalculate GΩ(k), the angular domain gain in direction k for an array with specified element weights.\n\nArguments\n\nk_xyz\t\t\t    k-space vector.\nGe\t\t\t\t\tThe antena gain in direction k_xyz [dB].\nr_x \t\t\t\tThe placement of each antenna element. All elements are placed along the x-axis.\nelement_weights\t    The complex weight of each element.\n\nReferences\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Kspace.k2azimuth-Tuple{Vector}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.k2azimuth","text":"k2azimuth(k_xyz::Vector)::Real\n\nCalculate the azimuth angle ϕ from a k-space vector.\nThe azimuth angle is the angle between the projection of the vector on the XY-plane and the x-axis.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Kspace.k2elevation-Tuple{Vector}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.k2elevation","text":"k2elevation(k_xyz::Vector)::Real\n\nCalculate the elevation angle θ from a k-space vector.\nThe elevation angle is the angle between the z unit vector and the the k vector.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Kspace.k_xyz-Tuple{Real, Real, Real}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.k_xyz","text":"k_xyz(θ::Real, ϕ::Real, λ0::Real)::Vector\n\nCalculate k-space vector, representing antenna elevation and coordinates.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Kspace.maximum_element_separation-Tuple{Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Kspace.maximum_element_separation","text":"Calculate the maximum array element separation for maximum look angle. Result is fraction of wavelenth.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Window.cosine_q","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Window.cosine_q","text":"cosine_q(M::Integer, q, scale = true)::AbstractVector\n\nCreate a coseine^q weighting (window).\n\nArguments\n\nM       The length of the window.\nq       For q=0 yields a uniform weight,q=1 yelds a cosine weighting, and q=2 yields a Hanning weighting.\nscale   Max of window is 1, when not scaled. sum( cosine_q(M, q) ) = M when scaled.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> N = 64;\n\njulia> W = Window.cosine_q(N, 1);\n\njulia> round.( W[1:4], sigdigits=3 )\n4-element Vector{Float64}:\n 0.0385\n 0.116\n 0.192\n 0.269\n\njulia> round( sum(W), sigdigits=2)\n64.0\n\nReferences\n\nS. Yan, Broadband Array Processing, Springer, 2019\n\n\n\n\n\n","category":"function"},{"location":"#ArrayRadiation.Window.rangeOmit-Tuple{Any, Any}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Window.rangeOmit","text":"Returns 1:n but omits m.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Window.split_window-Tuple{AbstractVector}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Window.split_window","text":"split_window(W::AbstractVector)::AbstractVector\n\nSplit a window to create a difference beam\n\nArguments\n\nW       The window to split.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> N = 64;\n\njulia> W = Window.taylor(N, 4, -35);\n\njulia> W = Window.split_window(W);\n\njulia> round.( W[1:4], sigdigits=3 )\n4-element Vector{Float64}:\n 0.28\n 0.288\n 0.305\n 0.329\n\n\njulia> round.( W[N-3:N], sigdigits=3 )\n4-element Vector{Float64}:\n -0.329\n -0.305\n -0.288\n -0.28\n\nBelow is an example of a split Taylor window.\n\n\n\n\n\n","category":"method"},{"location":"#ArrayRadiation.Window.taylor-Tuple{Integer, Integer, Real}","page":"ArrayRadiation.jl Documentation","title":"ArrayRadiation.Window.taylor","text":"taylor(N::Integer, n_bar::Integer, sll_dB::Real)::AbstractVector\n\nCreate taylor weighting (window).\n\nArguments\n\nN       The window length.\nn_bar   The number of nearly constant-level sidelobes adjacent to the main lobe.\nsll_dB  Peak sidelobe_level in dB.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> W = Window.taylor(64, 4, -35);\n\njulia> round.( W[1:4], sigdigits=3 )\n4-element Vector{Float64}:\n 0.28\n 0.288\n 0.305\n 0.329\n\njulia> round( sum(W), sigdigits=5)\n64.0\n\nReferences\n\nCarrar, Goodman and Majewski, Spotlight Synthetic Aperture Radar: Signal Processing Algorithms, Artech House, 1995\n\n\n\n\n\n","category":"method"},{"location":"Examples/monopulse_pattern/#Monopulse-Pattern","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"","category":"section"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"For monopulse radar processing, we use a sum beam and a difference beam (on reception) in each axis, to estimate an angle to a target with the goal of tracking it.","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"We can create these two beams by playing with the element weights.","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\nelement_count = 32;\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\n# Antenna element weight\nW = Window.taylor(32,4,-25)\nW2 = Window.split_window(copy(W))\n\nscatter(r, W, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=false, \n    grid=true,\n)\nscatter!(r, W2)","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"sum(W)","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"sum(W2)","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"Now lets compare their radiation pattern.","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"\nelevationRad = LinRange(π / 2, -π / 2, 501);\nk_xyz = 2π*Kspace.elevation2k_hat.(elevationRad)\nelevationDeg = rad2deg.(elevationRad);\n\n\n# Map K-space gain calculation function.\nGΩ(k) = ArrayRadiation.Kspace.gain_1D(k, 1, r, W)\nGΩ_lin = broadcast(GΩ, k_xyz)\n\n# Calculate\nGΩ_lin = Kspace.cos_taper.(elevationRad)\n\n\n# Map K-space gain calculation function.\nGΩ(k, _W) = Kspace.gain_1D(k, 1, r, _W)\nGΩ1_lin = map(k -> GΩ(k, W), k_xyz)\nGΩ2_lin = map(k -> GΩ(k, W2), k_xyz)\n\nGΩ1_dB = DspUtility.pow2db.(abs.(GΩ1_lin))\nGΩ2_dB = DspUtility.pow2db.(abs.(GΩ2_lin))\n\nplot(elevationDeg, GΩ1_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-30, 18),\n    reuse  = true,\n    label  = \"Sum Beam\"\n)\n\nplot!(elevationDeg, GΩ2_dB, \n    label  = \"Difference Beam\"\n)\n","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"As we can see, the difference beam is not great..","category":"page"}]
}
