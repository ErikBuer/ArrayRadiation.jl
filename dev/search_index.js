var documenterSearchIndex = {"docs":
[{"location":"Examples/element_radiation_pattern/#Element-Radiation-Pattern","page":"Element Radiation Pattern","title":"Element Radiation Pattern","text":"","category":"section"},{"location":"Examples/element_radiation_pattern/","page":"Element Radiation Pattern","title":"Element Radiation Pattern","text":"The package is bundled with the radiation pattern of some typical antennas.","category":"page"},{"location":"Examples/element_radiation_pattern/#Cosine-Taper","page":"Element Radiation Pattern","title":"Cosine Taper","text":"","category":"section"},{"location":"Examples/element_radiation_pattern/","page":"Element Radiation Pattern","title":"Element Radiation Pattern","text":"using GLMakie\nusing ArrayRadiation\n\nangleRad = LinRange(π / 2, -π / 2, 81);\n\nGe = AntennaElement.cos_taper.(angleRad)\nGe_dB = DspUtility.pow2db(Ge)\n\ny_lower_limit = -30 # dB\nGe_dB = clamp.(Ge_dB, y_lower_limit, Inf)\n\n# Create figure and polar axis\nf = Figure()\nax = PolarAxis(f[1, 1], \n    title = \"Cosine Taper\",\n    thetalimits = (-pi/2, pi/2),\n    radius_at_origin = -30,\n    theta_0 = -pi/2,\n    direction = -1,\n)\nlines!(ax, angleRad, Ge_dB, color = :blue, linewidth = 2)\nf","category":"page"},{"location":"Examples/element_radiation_pattern/","page":"Element Radiation Pattern","title":"Element Radiation Pattern","text":"using GLMakie\nusing ArrayRadiation\n\n\n# Coordinate space to be modeled\nφs = range(0, 2π, length=361)   # angle within xy-plane relative to +x\nθs = range(0, π, length=181)    # angle relative to +z\nangles = [(φ,θ) for φ in φs, θ in θs]\n\n# Our antennas gain as a function of elevation and azimuth angle.\nGe(θ,φ) = AntennaElement.cos_taper(θ)\n\n# Get radius (the Element Gain) at each angle\nrs = [Ge(θ, φ) for (φ,θ) in angles]\n\n# Convert this data to a 2D mesh\nspherical_mesh = [(r,φ,θ) for (r,(φ,θ)) in zip(rs,angles)]\n\n# Convert spherical coordinates to rectangular coordinates\nxs = [r*sin(θ)*cos(φ) for (r,φ,θ) in spherical_mesh]\nys = [r*sin(θ)*sin(φ) for (r,φ,θ) in spherical_mesh]\nzs = [r*cos(θ)        for (r,φ,θ) in spherical_mesh]\n\n\n# Plot\nfig = Figure()\nax = Axis3(fig[1,1])\nplt = surface!(ax, xs, ys, zs,\n    color=rs,\n    colormap=:jet1\n)\nColorbar(fig[1,2], plt, label=\"Gain\")\nfig","category":"page"},{"location":"Examples/element_radiation_pattern/#Half-Wave-Dipole","page":"Element Radiation Pattern","title":"Half-Wave Dipole","text":"","category":"section"},{"location":"Examples/element_radiation_pattern/","page":"Element Radiation Pattern","title":"Element Radiation Pattern","text":"using GLMakie\nusing ArrayRadiation\n\nangleRad = LinRange(-π, π, 181);\n\nGe = AntennaElement.half_wave_dipole.(angleRad)\nGe_dB = DspUtility.pow2db(Ge)\n\ny_lower_limit = -30 # dB\nGe_dB = clamp.(Ge_dB, y_lower_limit, Inf)\n\n# Create figure and polar axis\nf = Figure()\nax = PolarAxis(f[1, 1], \n    title = \"Half-Wave Dipole\",\n    #thetalimits = (-pi/2, pi/2),\n    radius_at_origin = -30,\n    theta_0 = -pi/2,\n    direction = -1,\n)\nlines!(ax, angleRad, Ge_dB, color = :blue, linewidth = 2)\nf","category":"page"},{"location":"Examples/element_radiation_pattern/#Cardioid","page":"Element Radiation Pattern","title":"Cardioid","text":"","category":"section"},{"location":"Examples/element_radiation_pattern/","page":"Element Radiation Pattern","title":"Element Radiation Pattern","text":"using GLMakie\nusing ArrayRadiation\n\nangleRad = LinRange(-π, π, 161);\n\nGe = AntennaElement.cardioid.(angleRad)\nGe_dB = DspUtility.pow2db(Ge)\n\ny_lower_limit = -30 # dB\nGe_dB = clamp.(Ge_dB, y_lower_limit, Inf)\n\n# Create figure and polar axis\nf = Figure()\nax = PolarAxis(f[1, 1], \n    title = \"Cardioid\",\n    #thetalimits = (-pi/2, pi/2),\n    radius_at_origin = -30,\n    theta_0 = -pi/2,\n    direction = -1,\n)\nlines!(ax, angleRad, Ge_dB, color = :blue, linewidth = 2)\nf","category":"page"},{"location":"Examples/element_radiation_pattern/#Microstrip-Patch","page":"Element Radiation Pattern","title":"Microstrip Patch","text":"","category":"section"},{"location":"Examples/element_radiation_pattern/","page":"Element Radiation Pattern","title":"Element Radiation Pattern","text":"using GLMakie\nusing ArrayRadiation\n\nangleRad = LinRange(π / 2, -π / 2, 81);\n\nGe = AntennaElement.microstrip_patch.(angleRad)\nGe_dB = DspUtility.pow2db(Ge)\n\ny_lower_limit = -30 # dB\nGe_dB = clamp.(Ge_dB, y_lower_limit, Inf)\n\n# Create figure and polar axis\nf = Figure()\nax = PolarAxis(f[1, 1], \n    title = \"Microstrip Patch\",\n    thetalimits = (-pi/2, pi/2),\n    radius_at_origin = -30,\n    theta_0 = -pi/2,\n    direction = -1,\n)\nlines!(ax, angleRad, Ge_dB, color = :blue, linewidth = 2)\nf","category":"page"},{"location":"Examples/element_radiation_pattern/#Yagi-Uda","page":"Element Radiation Pattern","title":"Yagi Uda","text":"","category":"section"},{"location":"Examples/element_radiation_pattern/","page":"Element Radiation Pattern","title":"Element Radiation Pattern","text":"using GLMakie\nusing ArrayRadiation\n\nangleRad = LinRange(0, π, 81);\n\nGe = AntennaElement.yagi_uda.(angleRad)\nGe_dB = DspUtility.pow2db(Ge)\n\ny_lower_limit = -30 # dB\nGe_dB = clamp.(Ge_dB, y_lower_limit, Inf)\n\n# Create figure and polar axis\nf = Figure()\nax = PolarAxis(f[1, 1], \n    title = \"Yagi Uda\",\n    thetalimits = (-0, pi),\n    radius_at_origin = -30,\n    theta_0 = -pi/2,\n    direction = -1,\n)\nlines!(ax, angleRad, Ge_dB, color = :blue, linewidth = 2)\nf","category":"page"},{"location":"Examples/2D_array_3D_plot/#2D-Array-3D-Plot","page":"2D Array 3D Plot","title":"2D Array 3D Plot","text":"","category":"section"},{"location":"Examples/2D_array_3D_plot/","page":"2D Array 3D Plot","title":"2D Array 3D Plot","text":"using GLMakie\nusing Colors\n\nusing ArrayRadiation\n\n# Define element spacing and array size\nelement_separation_λ = 1/2;\naxis_element_count = 32;\n\n# Generate antenna element positions\nr_xyz = ArrayRadiation.antenna_matrix(axis_element_count, axis_element_count, element_separation_λ)\n\n# Define angles in spherical coordinates\nθs = range(0, π/2, length=361)  # Elevation angles\nφs = range(-π, π,  length=361)  # Azimuth angles\nangles = [(φ,θ) for φ in φs, θ in θs]\n\n# Define element gain function\n_element_gain(elevation) = AntennaElement.cos_taper(elevation, 1.4)\n\n# Compute gain for each angle\n_GΩ(θ, φ) = Kspace.gain(Kspace.k_xyz(θ, φ), AntennaElement.cos_taper(θ), r_xyz, ones(axis_element_count, axis_element_count))\n\n# Compute k-space vectors and gain values\nrs = [_GΩ(θ, φ) for (φ,θ) in angles]\n\n# Convert the gain to dB\nrs_dB = DspUtility.pow2db.(abs.(rs))\n\nmin_value_dB = -20\nrs_dB = clamp.(rs_dB, min_value_dB, Inf)\nrs_dB = rs_dB .- min_value_dB # Ensure there only are possitive values.\n\nspherical_mesh = [(r,φ,θ) for (r,(φ,θ)) in zip(rs_dB, angles)]\n\n# Convert spherical to Cartesian coordinates\nxs = [r * sin(θ) * cos(φ) for (r, φ, θ) in spherical_mesh]\nys = [r * sin(θ) * sin(φ) for (r, φ, θ) in spherical_mesh]\nzs = [r * cos(θ)          for (r, φ, θ) in spherical_mesh]\n\nmax_range = 1 + maximum(abs, vcat(xs, ys, zs))  # Find max value across all coordinates\n\n","category":"page"},{"location":"Examples/2D_array_3D_plot/","page":"2D Array 3D Plot","title":"2D Array 3D Plot","text":"In order to plot the radiation pattern in 3D and dB, we need to clip the lowest values and bias the gain so it is purely positive. This makes the axis in the plot biased, but the relative scaling remains intact.","category":"page"},{"location":"Examples/2D_array_3D_plot/","page":"2D Array 3D Plot","title":"2D Array 3D Plot","text":"# Plot the 3D gain pattern\nfig = Figure()\nax = Axis3(fig[1, 1], title=\"Array Gain Pattern [dB]\")\nlimits!(ax, -max_range/2, max_range/2, -max_range/2, max_range/2, 0, max_range)\nplt = surface!(ax, xs, ys, zs, color=rs_dB, colormap=:jet1)\n\nfig","category":"page"},{"location":"Examples/2D_array_3D_plot/","page":"2D Array 3D Plot","title":"2D Array 3D Plot","text":"To give some sense of the radiation pattern in relation to the array, let's draw a generic patch antenna array.","category":"page"},{"location":"Examples/2D_array_3D_plot/","page":"2D Array 3D Plot","title":"2D Array 3D Plot","text":"\nvisual_scale = 3.0  # Scaling factor for visualization\n\npatch_width  = 0.3163 * visual_scale # wavelengths\npatch_length = 0.2207 * visual_scale # wavelengths\n\nsubstrate_width  = axis_element_count * element_separation_λ * visual_scale\nsubstrate_length = axis_element_count * element_separation_λ * visual_scale\nsubstrate_thickness = 0.06   * visual_scale # wavelengths\n\n\n# Draw substrate with teflon color (light off-white)\nsubstrate_color = RGB(0.9, 0.9, 0.9)  # Light gray/teflon color\n# Copper color for the patches\ncopper_color = RGB(0.72, 0.45, 0.2)  # Copper color (reddish-brown)\n\nfunction rectangle(center_xyz::Vector, width::Float64, height::Float64)\n    # Extract the center coordinates\n    x_center, y_center, z_center = center_xyz\n\n    # Define the half-width and half-height\n    half_width = width / 2\n    half_height = height / 2\n\n    # Define the four corners of the rectangle (in the XY plane)\n    vertices = [\n        x_center - half_width  y_center - half_height z_center;  # Point 1\n        x_center + half_width  y_center - half_height z_center;  # Point 2\n        x_center + half_width  y_center + half_height z_center;  # Point 3\n        x_center - half_width  y_center + half_height z_center   # Point 4\n    ]\n\n    # Define the two triangles (faces) making up the rectangle\n    faces = [\n        1 2 3;  # First triangle\n        3 4 1   # Second triangle\n    ]\n\n    return (vertices, faces)\nend\n\n\n# Plot the substrate at z = 0\nsubstrate_center = [0.0, 0.0, 0.0]\nvertices_substrate, faces_substrate = rectangle(substrate_center, substrate_width, substrate_length)\nmesh!(ax, vertices_substrate, faces_substrate, color=substrate_color, shading=NoShading)\n\n# Plot each patch at positions specified in r_xyz\nfor element_pos in r_xyz\n    _x, _y, _ = element_pos .* visual_scale\n    # Each patch is placed at (x, y, 0) from r_xyz\n    patch_center = [_x, _y, substrate_thickness]\n    vertices_patch, faces_patch = rectangle(patch_center, patch_width, patch_length)\n    \n    # Plot the patch with copper color\n    mesh!(ax, vertices_patch, faces_patch, color=copper_color, shading=NoShading)\nend\n\n\n# Hide axis\nhidespines!(ax)\nhidedecorations!(ax)\nhidedecorations!(ax, ticks = false)\nhidedecorations!(ax, grid = false)\n\n\n# Display the figure\nfig","category":"page"},{"location":"Examples/1D_array/#1D-Array","page":"1D Array","title":"1D Array","text":"","category":"section"},{"location":"Examples/1D_array/#1D-Radiation-Pattern","page":"1D Array","title":"1D Radiation Pattern","text":"","category":"section"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"Let's create an array and look at its radiation pattern.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"First, we must place the antenna elements. Let's give them λ/2 spacing and spread them linearly.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"using Plots;\ngr();\nusing LaTeXStrings\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\n\n# Place elements symmetrically around zero\nelement_count = 32;\n\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\nscatter(r, zeros(length(r)), \n    markershape=:circle, \n    # markercolor=:blue, \n    markersize=4, \n    xlabel=\"Position [λ]\", \n    title=\"Element Positions\", \n    legend=false, \n    #grid=false,\n    yticks= false,\n    ylims  = (-1, 1),\n)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"These elements now represent the antenna placements. We use the cos_taper function to approximate the element gain.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"angleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nelement_gain_approximation = AntennaElement.cos_taper.(angleRad)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"We can apply different weights to each element to create different beam directions.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"But in this example, we give all elements a uniform weight:","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"# Antenna element weight\nW = ones(element_count)\n\nscatter(r, W, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=false, \n    grid=true,\n    ylims  = (0, 1.1),\n)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"With this defined, we can calculate the radiation pattern of the array.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"The propagation direciton is decided by the vector veck, as opposed to elevation and azimuth angles (θ ϕ).","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"veck = frac2πλ_0","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"# Calculate K-space vectors\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\n# Map K-space gain calculation function.\nGΩ(k) = Kspace.gain_1D(k, 1, r, W)\nGΩ_lin = broadcast(GΩ, k_xyz).*element_gain_approximation\n\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\nplot(angleDeg, GΩ_dB,\n    xlabel = \"Elevation [deg]\",\n    ylabel = L\"G_Ω\\; [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-30, 18),\n    reuse  = true,\n    legend = false\n)\n","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"We can now inspect the radiation pattern in one dimension. This is useful to get a sense of the performance.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"However, one is often interested in the complete radiation pattern in all dimensions.","category":"page"},{"location":"Examples/1D_array/#2D-Radiation-Pattern","page":"1D Array","title":"2D Radiation Pattern","text":"","category":"section"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"The element radiation pattern cos_taper only radiates forward, so a 2D plot shows all the details of the current array.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"For simplicity, we calculate the radiation pattern from k_x k_y  -2pi 2pi.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"veck = k_xhatx + k_yhaty + k_zhatz","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"This yields invalid veck vectors with a magnitude greater than 2π (in our case) in the corners of the plot.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"But as you can see in the resulting radiation pattern, due to our element gain pattern, the array gain is nothing here anyway.","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"resolution = 201\n\n# Create a 2D grid for x and y values\nx_vals = LinRange(-1, 1, resolution)\ny_vals = LinRange(-1, 1, resolution)\n\n# Initialize matrices to store the k-values\nk_z = zeros(resolution, resolution)\nGΩ_lin = zeros(resolution, resolution)\n\nfor m in 1:resolution\n    for n in 1:resolution\n        k_z[m, n] = sqrt(max(0, 1 - x_vals[n]^2 - y_vals[m]^2))\n    end\nend\n\nheatmap(x_vals, y_vals, k_z, \n    xlabel=L\"\\hat{k}_x\",\n    ylabel=L\"\\hat{k}_y\",\n    title=\"Values of \"*L\"\\hat{k}_z\",\n    color=:jet1\n)","category":"page"},{"location":"Examples/1D_array/","page":"1D Array","title":"1D Array","text":"element_gain(elevation) = AntennaElement.cos_taper.(elevation, 1.4)\n\n# Calculate k_z values and gain values\nfor m in 1:resolution\n    for n in 1:resolution\n        k_x = x_vals[n]\n        k_y = y_vals[m]\n        k_z = sqrt(max(0, 1 - k_x^2 - k_y^2))\n        \n        # Create the k vector for each (k_x, k_y, k_z) triplet\n        k_xyz = 2π.*[k_x, k_y, k_z]\n\n        θ = Kspace.k2elevation(k_xyz)\n        \n        # Calculate the gain using the provided Kspace.gain_1D function\n        GΩ_lin[m, n] = GΩ(k_xyz)*element_gain(θ)\n        \n    end\nend\n\n# Convert the gain to dB\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\nGΩ_dB = clamp.(GΩ_dB, -40, Inf)\n\n# Plot the result as a heatmap\nheatmap(x_vals, y_vals, GΩ_dB, \n    xlabel=L\"\\hat{k}_x\", \n    ylabel=L\"\\hat{k}_y\", \n    title=L\"G_Ω(\\vec{k})\\; [dB]\", color=:jet1\n)","category":"page"},{"location":"Examples/2D_array/#2D-Array","page":"2D Array","title":"2D Array","text":"","category":"section"},{"location":"Examples/2D_array/#1D-Radiation-Pattern","page":"2D Array","title":"1D Radiation Pattern","text":"","category":"section"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"Let's create an array and look at its radiation pattern.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"First, we must place the antenna elements. Let's give them λ/2 spacing and spread them linearly.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"using Plots;\ngr();\nusing LaTeXStrings\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\n\n# Place elements symmetrically around zero\naxis_element_count = 32;\n\nr_xyz = ArrayRadiation.antenna_matrix(axis_element_count, axis_element_count, element_separation_λ)\n\n\n# Flatten and extract x and y coordinates\nx_positions = [r[1] for r in vec(r_xyz)]\ny_positions = [r[2] for r in vec(r_xyz)]\n\n# Plot\nscatter(x_positions, y_positions, \n    markershape=:circle, \n    markersize=4, \n    xlabel=\"X [λ]\", \n    ylabel=\"Y [λ]\", \n    title=\"Element Positions\", \n    legend=false, \n    grid=true\n)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"These elements now represent the antenna placements. We use the cos_taper function to approximate the element gain.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"angleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nelement_gain_approximation = AntennaElement.cos_taper.(angleRad)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"We can apply different weights to each element to create different beam directions.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"But in this example, we give all elements a uniform weight:","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"# Antenna element weight\nW = ones(axis_element_count, axis_element_count)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"With this defined, we can calculate the radiation pattern of the array.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"The propagation direciton is decided by the vector veck, as opposed to elevation and azimuth angles (θ ϕ).","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"veck = frac2πλ_0","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"# Calculate K-space vectors\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\n# Map K-space gain calculation function.\nGΩ(k) = Kspace.gain(k, 1, r_xyz, W)\nGΩ_lin = broadcast(GΩ, k_xyz).*element_gain_approximation\n\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\nplot(angleDeg, GΩ_dB,\n    xlabel = \"Elevation [deg]\",\n    ylabel = L\"G_Ω\\; [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-20, 30),\n    reuse  = true,\n    legend = false\n)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"We can now inspect the radiation pattern in one dimension. This is useful to get a sense of the performance.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"However, one is often interested in the complete radiation pattern in all dimensions.","category":"page"},{"location":"Examples/2D_array/#2D-Radiation-Pattern","page":"2D Array","title":"2D Radiation Pattern","text":"","category":"section"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"The element radiation pattern cos_taper only radiates forward, so a 2D plot shows all the details of the current array.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"For simplicity, we calculate the radiation pattern from k_x k_y  -2pi 2pi.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"veck = k_xhatx + k_yhaty + k_zhatz","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"This yields invalid veck vectors with a magnitude greater than 2π (in our case) in the corners of the plot.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"But as you can see in the resulting radiation pattern, due to our element gain pattern, the array gain is nothing here anyway.","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"resolution = 201\n\n# Create a 2D grid for x and y values\nx_vals = LinRange(-1, 1, resolution)\ny_vals = LinRange(-1, 1, resolution)\n\n# Initialize matrices to store the k-values\nk_z = zeros(resolution, resolution)\nGΩ_lin = zeros(resolution, resolution)\n\nfor m in 1:resolution\n    for n in 1:resolution\n        k_z[m, n] = sqrt(max(0, 1 - x_vals[n]^2 - y_vals[m]^2))\n    end\nend\n\nheatmap(x_vals, y_vals, k_z, \n    xlabel=L\"\\hat{k}_x\",\n    ylabel=L\"\\hat{k}_y\",\n    title=\"Values of \"*L\"\\hat{k}_z\",\n    color=:jet1\n)","category":"page"},{"location":"Examples/2D_array/","page":"2D Array","title":"2D Array","text":"element_gain(elevation) = AntennaElement.cos_taper.(elevation, 1.4)\n\n# Calculate k_z values and gain values\nfor m in 1:resolution\n    for n in 1:resolution\n        k_x = x_vals[n]\n        k_y = y_vals[m]\n        k_z = sqrt(max(0, 1 - k_x^2 - k_y^2))\n        \n        # Create the k vector for each (k_x, k_y, k_z) triplet\n        k_xyz = 2π.*[k_x, k_y, k_z]\n\n        θ = Kspace.k2elevation(k_xyz)\n        GΩ_lin[m, n] = GΩ(k_xyz)*element_gain(θ)\n        \n    end\nend\n\n# Convert the gain to dB\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\nGΩ_dB = clamp.(GΩ_dB, -40, Inf)\n\n# Plot the result as a heatmap\nheatmap(x_vals, y_vals, GΩ_dB, \n    xlabel=L\"\\hat{k}_x\", \n    ylabel=L\"\\hat{k}_y\", \n    title=L\"G_Ω(\\vec{k})\\; [dB]\",\n    color=:jet1\n)","category":"page"},{"location":"Examples/window_function/#Window-Function","page":"Window Function","title":"Window Function","text":"","category":"section"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\nelement_count = 32;\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"These elements now represent antennas. For the time being, these will be isotropic radiators. We can apply different weights to each element so let's look at how this will affect our array.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"Let's compare a linear weight to a commonly used Taylor weighting scheme.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"# Antenna element weight\nW = ones(element_count)\nW2 = Window.taylor(32,4,-25)\n\nscatter(r, W, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=false, \n    grid=true,\n)\nscatter!(r, W2)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"As we can see, both weight functions have the same sum.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"sum(W)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"sum(W2)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"Now lets compare their radiation pattern.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\nelement_gain_approximation = AntennaElement.cos_taper.(angleRad)\n\n\n# Map K-space gain calculation function.\nGΩ(k, _W) = Kspace.gain_1D(k, 1, r, _W)\nGΩ1_lin = map(k -> GΩ(k, W), k_xyz).*element_gain_approximation\nGΩ2_lin = map(k -> GΩ(k, W2), k_xyz).*element_gain_approximation\n\nGΩ1_dB = DspUtility.pow2db.(abs.(GΩ1_lin))\nGΩ2_dB = DspUtility.pow2db.(abs.(GΩ2_lin))\n\nplot(angleDeg, GΩ1_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-30, 18),\n    reuse  = true,\n    label  = \"Uniformly weighted\"\n)\n\nplot!(angleDeg, GΩ2_dB, \n    label  = \"Taylor weighted\"\n)","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"It is apparent that the Taylor weighted antenna has a greater peak-to-sidelobe distance, comming with the penalty of a wider main beam.","category":"page"},{"location":"Examples/window_function/#Window-Comparisons","page":"Window Function","title":"Window Comparisons","text":"","category":"section"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"Weighting distributions (windows) have been studied extensively over the years. The reader is encouraged to read up on the different windows and their properties.","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"\nW3 = Window.cosine_q(element_count, 1)\nW4 = Window.cosine_q(element_count, 2)\n\n\nscatter(r, W2, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=true, \n    grid=true,\n    label  = \"Taylor weights\",\n)\nscatter!(r, W3, label  = \"Cosine weights\")\nscatter!(r, W4, label  = \"Hanning weights\")","category":"page"},{"location":"Examples/window_function/","page":"Window Function","title":"Window Function","text":"GΩ3_lin = map(k -> GΩ(k, W3), k_xyz).*element_gain_approximation\nGΩ4_lin = map(k -> GΩ(k, W4), k_xyz).*element_gain_approximation\n\nGΩ3_dB = DspUtility.pow2db.(abs.(GΩ3_lin))\nGΩ4_dB = DspUtility.pow2db.(abs.(GΩ4_lin))\n\nplot(angleDeg, GΩ2_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-50, 18),\n    reuse  = true,\n    label  = \"Taylor weighted\"\n)\n\nplot!(angleDeg, GΩ3_dB, \n    label  = \"Cosine weighted\"\n)\n\nplot!(angleDeg, GΩ4_dB, \n    label  = \"Hanning weighted\"\n)","category":"page"},{"location":"Examples/beem_steering/#Beam-Steering","page":"Beam Steering","title":"Beam Steering","text":"","category":"section"},{"location":"Examples/beem_steering/","page":"Beam Steering","title":"Beam Steering","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\n\n# Place elements symmetrically around zero\nelement_separation_λ = 1/2;\nelement_count = 64;\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\n\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\nelement_gain_approximation = AntennaElement.cos_taper.(angleRad)\n\n\"\"\"\nInter-element phase shift for scanning in direction θ [rad].\n\"\"\"\nα(θ, d_λ) = 2π*d_λ*sin(θ);\n\n# Angles at which to scan the array.\nscan_angles = LinRange(-π / 2, π / 2, 81);\n\n# Use Hanning element weights. \nWp = Window.cosine_q(element_count, 2)\n\nplt1 = plot();\n\nanim = @animate for (index, scan_angle) in enumerate(scan_angles)\n\n\tphase_increment = α(scan_angle, 1/2)\n\tW_ang = LinRange(0, (element_count - 1) * phase_increment, element_count)\n\n\t# Antenna element complex weight\n\tW = Wp.*exp.(im .* W_ang) # Example of pointing to an angle.\n\n\t# Map K-space gain calculation function.\n\tGΩ(k) = ArrayRadiation.Kspace.gain_1D(k, 1, r, W)\n\n\tGΩ_lin = broadcast(GΩ, k_xyz).*element_gain_approximation\n\tGΩ_dB = broadcast(ArrayRadiation.DspUtility.pow2db, abs.(GΩ_lin))\n\n\tplot(angleDeg, GΩ_dB,\n\t\txlabel = \"Angle [deg]\",\n\t\tylabel = \"GΩ [dB]\",\n\t\ttitle  = \"Array Gain\",\n\t\tylims  = (-80, 20),\n\t\treuse  = true,\n\t\tlegend = false\n\t\t)\nend\n\ngif(anim, \"array_scan.gif\", fps = 10)\n","category":"page"},{"location":"Examples/linear_array_polar_gain_pattern/#Linear-Array-Polar-Gain-Pattern","page":"Linear Array Polar Gain Pattern","title":"Linear Array Polar Gain Pattern","text":"","category":"section"},{"location":"Examples/linear_array_polar_gain_pattern/","page":"Linear Array Polar Gain Pattern","title":"Linear Array Polar Gain Pattern","text":"using GLMakie\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\n\n# Place elements symmetrically around zero\nelement_count = 32;\n\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\nangleRad = LinRange(π / 2, -π / 2, 501);\nangleDeg = rad2deg.(angleRad);\n\nelement_gain_approximation = AntennaElement.cos_taper.(angleRad)\n\n# Uniform weights\nW = ones(element_count)\n\n\n# Calculate K-space vectors\nk_xyz = 2π*Kspace.elevation2k_hat.(angleRad)\n\n# Map K-space gain calculation function.\nGΩ(k) = Kspace.gain_1D(k, 1, r, W)\nGΩ_lin = broadcast(GΩ, k_xyz).*element_gain_approximation\n\nGΩ_dB = DspUtility.pow2db.(abs.(GΩ_lin))\n\n# Clamp dB values for readability\ny_lower_limit = -30\nGΩ_dB = clamp.(GΩ_dB, y_lower_limit, Inf)\n\nf = Figure()\nax = PolarAxis(f[1, 1], \n    title = \"Linear Array, Uniform Weights, $element_count Elements\",\n    thetalimits = (-pi/2, pi/2),\n    radius_at_origin = y_lower_limit,\n    theta_0 = -pi/2,\n    direction = -1,\n)\nlines!(ax, angleRad, GΩ_dB, color = :blue, linewidth = 2)\nf  # Display figure","category":"page"},{"location":"api_reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"Modules = [ArrayRadiation, ArrayRadiation.DspUtility, ArrayRadiation.Kspace, ArrayRadiation.Window, ArrayRadiation.AntennaElement]","category":"page"},{"location":"api_reference/#ArrayRadiation.DspUtility._mean-Tuple{Any}","page":"API Reference","title":"ArrayRadiation.DspUtility._mean","text":"_mean(x)::Real\n\nCalculate the mean of a vector. \n\njulia> using ArrayRadiation\n\njulia> a = [1,2,3,4];\n\njulia> ArrayRadiation.DspUtility._mean(a)\n2.5\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.antenna_matrix-Tuple{Any, Any, Any}","page":"API Reference","title":"ArrayRadiation.DspUtility.antenna_matrix","text":"antenna_matrix(M, N, separation)\n\nGenerate locations (2D) for an evenly spaced MxN matrix of antenna elements,  ensuring symmetry around the origin.\n\nAll elements are placed in the XY-plane.\n\nArguments\n\nM          : Number of elements along the Y-axis.\nN          : Number of elements along the X-axis.\nseparation : Distance between adjacent elements.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> DspUtility.antenna_matrix(1, 2, 0.5)\n1×2 Matrix{Tuple{Float64, Float64, Float64}}:\n (-0.25, 0.0, 0.0)  (0.25, 0.0, 0.0)\n\njulia> DspUtility.antenna_matrix(1, 3, 1/2)\n1×3 Matrix{Tuple{Float64, Float64, Float64}}:\n (-0.5, 0.0, 0.0)  (0.0, 0.0, 0.0)  (0.5, 0.0, 0.0)\n\njulia> DspUtility.antenna_matrix(2, 1, 1/2)\n2×1 Matrix{Tuple{Float64, Float64, Float64}}:\n (0.0, -0.25, 0.0)\n (0.0, 0.25, 0.0)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.db2mag-Tuple{Any}","page":"API Reference","title":"ArrayRadiation.DspUtility.db2mag","text":"Convert between decibal scale (magnitude) and linear\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.db2pow-Tuple{Any}","page":"API Reference","title":"ArrayRadiation.DspUtility.db2pow","text":"Convert between decibal scale (power) and linear\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.discard_low_values-Tuple{Real, Real}","page":"API Reference","title":"ArrayRadiation.DspUtility.discard_low_values","text":"discard_low_values(scalar_value::Real, lower_limit::Real)\n\nThis function takes a scalar value and compares it against a specified lower limit. If the scalar value is below the lower_limit, the function returns nothing. Otherwise, it returns the scalar value unchanged.\n\nArguments\n\nscalar_value::Real: The scalar value to compare.\nlower_limit::Real: The threshold value below which the scalar is discarded.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> ArrayRadiation.DspUtility.discard_low_values(50, 40)\n50\n\njulia> ArrayRadiation.DspUtility.discard_low_values(30, 40)\n\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.energy-Tuple{Any}","page":"API Reference","title":"ArrayRadiation.DspUtility.energy","text":"Return the signal energy in Joule\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.linear_array-Tuple{Any, Any}","page":"API Reference","title":"ArrayRadiation.DspUtility.linear_array","text":"Generate locations (1D) for a evenly spaced array of N elements. N is even.\n\nArguments\n\nN          \tNumber of elements (assumed to be even).\nseparation \tDistance between adjacent elements.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.mag2db-Tuple{Any}","page":"API Reference","title":"ArrayRadiation.DspUtility.mag2db","text":"Convert between linear scale (magnitude) and decibel \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.pow2db-Tuple{Any}","page":"API Reference","title":"ArrayRadiation.DspUtility.pow2db","text":"Convert between linear scale (magnitude) and decibel \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.power_dBW-Tuple{Any}","page":"API Reference","title":"ArrayRadiation.DspUtility.power_dBW","text":"Return the average signal power in dBW\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.DspUtility.power_dBm-Tuple{Any}","page":"API Reference","title":"ArrayRadiation.DspUtility.power_dBm","text":"Return the average signal power in dBm\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Kspace.azimuth2k_hat-Tuple{Real}","page":"API Reference","title":"ArrayRadiation.Kspace.azimuth2k_hat","text":"azimuth2k_hat(ϕ::Real)::Vector{Real}\n\nConvert an azimuth angle ϕ (in radians) to a unit-length k-space vector in the XY-plane.\n\nThe resulting vector has the form [cos(ϕ), sin(ϕ), 0].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Kspace.cos_taper_k_hat","page":"API Reference","title":"ArrayRadiation.Kspace.cos_taper_k_hat","text":"cos_taper_k_hat(k_hat_x::Real, k_hat_y::Real, α = 1.4)\n\nCalculate cosine taper for normalized k-space vector [kx, ky, kz]/|k|.\n\nWhere |k| = 2π/λ0\n\nOptionally provide α. α=1.4 accounts for mutual coupling between elements.\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#ArrayRadiation.Kspace.elevation2k_hat-Tuple{Real}","page":"API Reference","title":"ArrayRadiation.Kspace.elevation2k_hat","text":"elevation2k_hat(θ::Real)::Vector{Real}\n\nConvert an elevation angle θ (in radians) to a unit-length k-space vector in the XZ-plane.\n\nThe resulting vector has the form [sin(θ), 0, cos(θ)].\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Kspace.gain-Tuple{AbstractVector{<:Real}, Real, AbstractArray, AbstractArray}","page":"API Reference","title":"ArrayRadiation.Kspace.gain","text":"gain(k_xyz::AbstractVector{<:Real}, Ge::Real, r_xyz::AbstractArray, element_weights::AbstractArray)\n\nCalculate GΩ(k), the angular domain gain in direction k for an array with specified element weights.\n\nArguments\n\nk_xyz\t\t\t    k-space vector.\nGe\t\t\t\t\tThe antena gain in direction k_xyz.\nr_xyz \t\t\t\tThe placement of each antenna element. in \nelement_weights\t    The complex weight of each element. Must have the same size/shape as r_xyz.\n\nReferences\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Kspace.gain_1D-Tuple{AbstractVector{<:Real}, Real, AbstractVector, AbstractVector}","page":"API Reference","title":"ArrayRadiation.Kspace.gain_1D","text":"gain_1D(k_xyz::AbstractVector{<:Real}, Ge::Real, r_x::AbstractVector, element_weights::AbstractVector)\n\nCalculate GΩ(k), the angular domain gain in direction k for an array with specified element weights.\n\nArguments\n\nk_xyz\t\t\t    k-space vector.\nGe\t\t\t\t\tThe antena gain in direction k_xyz.\nr_x \t\t\t\tThe placement of each antenna element. All elements are placed along the x-axis.\nelement_weights\t    The complex weight of each element.\n\nReferences\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Kspace.k2azimuth-Tuple{Vector}","page":"API Reference","title":"ArrayRadiation.Kspace.k2azimuth","text":"k2azimuth(k_xyz::Vector)::Real\n\nCalculate the azimuth angle ϕ from a k-space vector.\n\nThe azimuth angle is the angle between the projection of the vector on the XY-plane and the x-axis.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Kspace.k2elevation-Tuple{Vector}","page":"API Reference","title":"ArrayRadiation.Kspace.k2elevation","text":"k2elevation(k_xyz::Vector)::Real\n\nCalculate the elevation angle θ from a k-space vector.\n\nThe elevation angle is the angle between the z unit vector and the the k vector.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Kspace.k_xyz","page":"API Reference","title":"ArrayRadiation.Kspace.k_xyz","text":"k_xyz(θ::Real, ϕ::Real, λ0::Real=1)::Vector\n\nCalculate k-space vector, representing antenna elevation and coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#ArrayRadiation.Kspace.maximum_element_separation-Tuple{Any}","page":"API Reference","title":"ArrayRadiation.Kspace.maximum_element_separation","text":"maximum_element_separation(max_look_angle_deg)\n\nCalculate the maximum array element separation for maximum look angle.\n\nResult is fraction of wavelenth.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Window.cosine_q","page":"API Reference","title":"ArrayRadiation.Window.cosine_q","text":"cosine_q(M::Integer, q, scale = true)::AbstractVector\n\nCreate a coseine^q weighting (window).\n\nArguments\n\nM       The length of the window.\nq       For q=0 yields a uniform weight,q=1 yelds a cosine weighting, and q=2 yields a Hanning weighting.\nscale   Max of window is 1, when not scaled. sum( cosine_q(M, q) ) = M when scaled.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> N = 64;\n\njulia> W = Window.cosine_q(N, 1);\n\njulia> round.( W[1:4], sigdigits=3 )\n4-element Vector{Float64}:\n 0.0385\n 0.116\n 0.192\n 0.269\n\njulia> round( sum(W), sigdigits=2)\n64.0\n\nReferences\n\nS. Yan, Broadband Array Processing, Springer, 2019\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#ArrayRadiation.Window.rangeOmit-Tuple{Any, Any}","page":"API Reference","title":"ArrayRadiation.Window.rangeOmit","text":"Returns 1:n but omits m.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Window.split_window-Tuple{AbstractVector}","page":"API Reference","title":"ArrayRadiation.Window.split_window","text":"split_window(W::AbstractVector)::AbstractVector\n\nSplit a window to create a difference beam\n\nArguments\n\nW       The window to split.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> N = 64;\n\njulia> W = Window.taylor(N, 4, -35);\n\njulia> W = Window.split_window(W);\n\njulia> round.( W[1:4], sigdigits=3 )\n4-element Vector{Float64}:\n 0.28\n 0.288\n 0.305\n 0.329\n\n\njulia> round.( W[N-3:N], sigdigits=3 )\n4-element Vector{Float64}:\n -0.329\n -0.305\n -0.288\n -0.28\n\nBelow is an example of a split Taylor window.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.Window.taylor-Tuple{Integer, Integer, Real}","page":"API Reference","title":"ArrayRadiation.Window.taylor","text":"taylor(N::Integer, n_bar::Integer, sll_dB::Real)::AbstractVector\n\nCreate taylor weighting (window).\n\nArguments\n\nN       The window length.\nn_bar   The number of nearly constant-level sidelobes adjacent to the main lobe.\nsll_dB  Peak sidelobe_level in dB.\n\nExample\n\njulia> using ArrayRadiation\n\njulia> W = Window.taylor(64, 4, -35);\n\njulia> round.( W[1:4], sigdigits=3 )\n4-element Vector{Float64}:\n 0.28\n 0.288\n 0.305\n 0.329\n\njulia> round( sum(W), sigdigits=5)\n64.0\n\nReferences\n\nCarrar, Goodman and Majewski, Spotlight Synthetic Aperture Radar: Signal Processing Algorithms, Artech House, 1995\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#ArrayRadiation.AntennaElement.cardioid","page":"API Reference","title":"ArrayRadiation.AntennaElement.cardioid","text":"cardioid(θ::AbstractFloat, ϕ::AbstractFloat=0.0)\n\nCalculate approximate radiation pattern for a cardioid antenna.\n\nArguments\n\nθ   Elevation [rad]\nϕ   Azimuth [rad]\n\nReferences\n\nCosta, Abrao, Rego, A Method for Approximating Directivity Expressions in Generalized Radiation Patterns, Elsevier, 2025.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#ArrayRadiation.AntennaElement.cos_taper","page":"API Reference","title":"ArrayRadiation.AntennaElement.cos_taper","text":"cos_taper(θ::Real, α = 1.4)\n\nCalculate cosine taper for elevation angle θ [rad]. Optionally provide α. α=1.4 accounts for mutual coupling between elements.\n\nR. A. Dana, Electronically Scanned Arrays and K-Space Gain Formulation, Springer, 2019.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#ArrayRadiation.AntennaElement.half_wave_dipole","page":"API Reference","title":"ArrayRadiation.AntennaElement.half_wave_dipole","text":"half_wave_dipole(θ::AbstractFloat, ϕ::AbstractFloat=0.0)\n\nCalculate approximate radiation pattern for a half wave dipole.\n\nArguments\n\nθ   Elevation [rad]\nϕ   Azimuth [rad]\n\nReferences\n\nCosta, Abrao, Rego, A Method for Approximating Directivity Expressions in Generalized Radiation Patterns, Elsevier, 2025.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#ArrayRadiation.AntennaElement.microstrip_patch","page":"API Reference","title":"ArrayRadiation.AntennaElement.microstrip_patch","text":"microstrip_patch(θ::AbstractFloat, ϕ::AbstractFloat=0.0)\n\nCalculate approximate radiation pattern for a microstrip patch antenna.\n\nThe model is only valid for θ ∈ [−π/2, π/2].\n\nArguments\n\nθ   Elevation [rad]\nϕ   Azimuth [rad]\n\nReferences\n\nCosta, Abrao, Rego, A Method for Approximating Directivity Expressions in Generalized Radiation Patterns, Elsevier, 2025.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#ArrayRadiation.AntennaElement.yagi_uda","page":"API Reference","title":"ArrayRadiation.AntennaElement.yagi_uda","text":"yagi_uda(θ::AbstractFloat, ϕ::AbstractFloat=0.0)\n\nCalculate approximate radiation pattern for a Yagi Uda antenna.\n\nThe model is only valid for θ ∈ [−π/2, π/2].\n\nThe model is based on the following geometry:\n\nThree directors, spaced 0.20λ apart.\nDirector lengths: [0.428λ, 0.424λ, 0.428λ]\nReflector length of 0.482λ\n\nArguments\n\nθ   Elevation [rad]\nϕ   Azimuth [rad]\n\nReferences\n\nCosta, Abrao, Rego, A Method for Approximating Directivity Expressions in Generalized Radiation Patterns, Elsevier, 2025.\n\n\n\n\n\n","category":"function"},{"location":"coordinate_system/#Coordinate-System","page":"Coordinate System","title":"Coordinate System","text":"","category":"section"},{"location":"coordinate_system/","page":"Coordinate System","title":"Coordinate System","text":"(Image: Coordinate system)","category":"page"},{"location":"#ArrayRadiation.jl","page":"ArrayRadiation.jl","title":"ArrayRadiation.jl","text":"","category":"section"},{"location":"#Features","page":"ArrayRadiation.jl","title":"Features","text":"","category":"section"},{"location":"","page":"ArrayRadiation.jl","title":"ArrayRadiation.jl","text":"Empirical radiation pattern models for common antennas\nCommon element weight functions (windows)\nCalculate gain pattern for arbitrary arrays\nSupport for regular and irregular arrays","category":"page"},{"location":"Examples/monopulse_pattern/#Monopulse-Pattern","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"","category":"section"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"For monopulse radar processing, we use a sum beam and a difference beam (on reception) in each axis, to estimate an angle to a target with the goal of tracking it.","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"We can create these two beams by playing with the element weights.","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"using Plots;\ngr();\n\nusing ArrayRadiation\n\nelement_separation_λ = 1/2;\nelement_count = 32;\nr = ArrayRadiation.linear_array(element_count, element_separation_λ)\n\n# Antenna element weight\nW = Window.taylor(32,4,-25)\nW2 = Window.split_window(copy(W))\n\nscatter(r, W, \n    marker=:circle, \n    linecolor=:blue, \n    markersize=4, \n    xlabel=\"Element Position [λ]\", \n    ylabel=\"Weight\", \n    title=\"Antenna Element Weights\", \n    legend=false, \n    grid=true,\n)\nscatter!(r, W2)","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"sum(W)","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"sum(W2)","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"Now let's compare their radiation pattern.","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"\nelevationRad = LinRange(π / 2, -π / 2, 501);\nk_xyz = 2π*Kspace.elevation2k_hat.(elevationRad)\nelevationDeg = rad2deg.(elevationRad);\n\n\n# Map K-space gain calculation function.\nGΩ(k) = ArrayRadiation.Kspace.gain_1D(k, 1, r, W)\nGΩ_lin = broadcast(GΩ, k_xyz)\n\n# Calculate\nGΩ_lin = AntennaElement.cos_taper.(elevationRad)\n\n\n# Map K-space gain calculation function.\nGΩ(k, _W) = Kspace.gain_1D(k, 1, r, _W)\nGΩ1_lin = map(k -> GΩ(k, W), k_xyz)\nGΩ2_lin = map(k -> GΩ(k, W2), k_xyz)\n\nGΩ1_dB = DspUtility.pow2db.(abs.(GΩ1_lin))\nGΩ2_dB = DspUtility.pow2db.(abs.(GΩ2_lin))\n\nplot(elevationDeg, GΩ1_dB,\n    xlabel = \"Angle [deg]\",\n    ylabel = \"GΩ [dB]\",\n    title  = \"Array gain\",\n    ylims  = (-30, 18),\n    reuse  = true,\n    label  = \"Sum Beam\"\n)\n\nplot!(elevationDeg, GΩ2_dB, \n    label  = \"Difference Beam\"\n)\n","category":"page"},{"location":"Examples/monopulse_pattern/","page":"Monopulse Pattern","title":"Monopulse Pattern","text":"As we can see, the difference beam is not great..","category":"page"}]
}
